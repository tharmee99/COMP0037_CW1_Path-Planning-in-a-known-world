%***************************************PREAMBLE***************************************
\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[margin=0.7in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{setspace}
\usepackage{appendix}

%***************************************DOCUMENT***************************************

\begin{document}
	\fontfamily{ptm}\selectfont
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%COVERSHEET%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{titlepage}
		\setlength{\voffset}{-0.8in}
		\noindent \makebox[\textwidth]{\includegraphics[width=1.2\textwidth]{images/Coversheet_Header.png}}
	
			\vspace{15mm}
			
			\begin{center}
				{\Huge \textbf{COMP0037 \\ \vspace{10mm} Report}}
			
				\vspace{8mm}
			
				\begin{spacing}{1.8}
					{\huge Path Planning in a Known World}
				\end{spacing}
		
			
				\vspace{12mm}
			
				{\LARGE \textbf{Group AS}}
				
				\vspace{10mm}
				
				\begin{tabular}{ll}
					\underline{\textbf{Student Name}}  & \hspace{4mm} \underline{\textbf{Student number}} \vspace{2mm} \\
					Arundathi Shaji Shanthini & \hspace{4mm} 16018351 \\ 
					Dmitry Leyko & \hspace{4mm}  16021440\\ 
					Tharmetharan Balendran & \hspace{4mm} 17011729\\ 
				\end{tabular}
				
				\vspace{13mm}
				
				\begin{tabular}{ll}
					\textbf{Department:} &  Department of Electronics and Electrical Engineering\\ \vspace{3mm}
					\textbf{Submission Date:} &  25\textsuperscript{th} of February 2020
				\end{tabular}
			\end{center}
	\end{titlepage}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\pagebreak
	
	\tableofcontents
	
	\pagebreak
	
	%%%%%%%%%%% PART 1 %%%%%%%%%%%%%%%%%
	\section{Implement and Investigate Properties of Path Planning Algorithms}
		
		\subsection{Path Planning Algorithms}
				
			\begin{figure}[H]
				\renewcommand\thefigure{1.1}
				\centering
				
				\includegraphics[scale=0.6]{images/general_forward_search_pseudocode.png}
				\caption{The general forward search algorithm pseudo-code. }
			\end{figure}
			
			All of the path planning algorithms have the same backbone and can be summed up into 15 lines of pseudo-code shown in Fig 1.1. This algorithm describes the process of finding a path from a cell ($x_I$) to a goal cell ($X_G$). This general algorithm is called the general forward search algorithm and is implemented in the \textbf{GeneralForwardSearchAlgorithm} class. All planners that are implemented inherit from this class through the \textbf{CellBasedForwardSearch} class. The search algorithm is similar for all the planners and has also been implemented in the same \textbf{GeneralForwardSearchAlgorithm} class. What differs between the planners is the type of queue that is used and the implementation of the \textbf{resolveDuplicate} function. These properties and functions are defined in the classes of each of the individual planners. It should also be noted that a class named \textbf{PlannerBase} is also present. This function consists of abstract functions and variable decelerations as well as functions required for visualisation of the planned path. The high-level working of the planners we implemented and their properties are described below.
			
			\subsubsection{FIFO - Breadth First Search}
	
				This algorithm works by selecting a particular cell and exploring its neighbours first. It would then pivot around those neighbours to explore each of their neighbours. Layer by layer it will explore all the cells on the graph network until it reaches the goal. The next cells to be considered are chosen by first considering the cell directly underneath and then considering the neighbouring cells going anti-clockwise. This way of allocating the next set of cells to be considered, is the same for all algorithms. The Breadth First Algorithm uses a queue to keep track of the order of the exploration in the network. If a particular cell shows itself twice to the algorithm, it will use the first instance of it ignoring the second. The first path that reaches the finishing cell is the final output path, no mater of the cost. The name First in First Out (FIFO) comes from the type of queue implemented in this search algorithm. The next cell to be considered at any point is the one that was added the first out of all the cells in the queue.
				\\
				The Breadth First Search Algorithm utilizes a normal unsorted queue and was implemented using the python \textbf{deque} class. For the pushing and popping of cells, the in-built \textbf{append} and \textbf{popleft} functions were utilized. In the case a cell that was already visited is re-visited in the Breadth First Search, nothing is considered. Therefore the \textbf{resolveDuplicate} function is an empty function in this case. 
				\\
				The biggest advantage of FIFO is that it will never get stuck in a blind alley. If there is a solution it will find it. If there are multiple solutions, it will find one with the least steps. The memory usage can be large as it stores all the cells that it visits. If the solution is far, it might take a lot of time to find, as well as that the FIFO algorithm does not guarantee optimality. In the worst case scenario with the FIFO algorithm will consider every possible cell and edge. Therefore the complexity can be expressed as $O(V+E)$ where V is the total number of vertices/cells and E is the total number of edges in the graph. 
			
			\subsubsection{LIFO - Depth First Search}
			
				This algorithm is very similar to the Breadth First Search. Starting from the initial cell, the algorithm adds cells to the queue in the same fashion as previously described. Where Depth First differs is in the fact that instead of using a first in first out queue, a last in first out (LIFO) queue is utilized. As a result at any given moment the next cell to be considered is the last one that was added to the queue. 
				\\
				The depth first algorithm utilizes a normal python \textbf{list} class alongside the \textbf{pop} and \textbf{append} functions. Once again, in the event a cell is revisited the first instance is considered. This results in an empty implementation of \textbf{resolveDuplicate}. 
				\\
				Once again, the depth first algorithm does not grantee the optimal path. In fact, due to the nature of the LIFO queue, the computed paths tend to be chaotic with many zig-zag features. Similarly to the Breadth First Algorithm, in the worst case scenario the Depth first algorithm will consider each cell of the graph. This means that once again the complexity of the algorithm can be expressed as $O(V+E)$ where V is the total number of vertices/cells and E is the total number of edges in the graph.
			
			\subsubsection{Greedy Search}
			
				The Greedy Search Algorithm starts at the first cell and adds neighbouring cells to the queue. The type of queue used in this algorithm is a priority queue with the priority value being the euclidean distance between the cell and the goal. This means that the cells in the queue are sorted by their euclidean distance to the goal. As a result when a cell is popped from the queue it will be the cell with the lowest euclidean distance to the goal (out of the cells in the queue). As a result the algorithm will consider the cells closer to the goal first. This can drastically reduce the number of cells that are considered resulting in lower computational requirement.
				\\
				The greedy algorithm was implemented using a priority queue from the \textbf{PriorityQueue} library. Along with the built-in \textbf{put}, \textbf{get} and \textbf{empty} functions it was relatively easy to implement the priority queue and thereby the greedy algorithm. Once again in the case a cell is revisited nothing is done, meaning that the \textbf{resolveDuplicate} function is empty.
				\\
				The biggest advantage of the greedy algorithm is its easy implementation and its efficiency in simple cases. In maps with minimal/no obstructions, the greedy algorithm is able to find a path with significantly fewer cells visited compared to breadth first and depth first planners. However the optimality of the path is not guaranteed.
				
			\subsubsection{Dijkstra's}
			
				This algorithm works by first setting the values for distances to every cell to infinity. Once the starting cell is specified, its cost to go value is set to zero and it is set to have no parent cell. The algorithm then explores the neighbours of the starting cell and records the distance to each. Once this is done, the neighbouring cells are added to the queue which is once again a priority queue with the priority value being the cost to go to the cell. The next cell to be considered is the cell with the lowest cost to go (from the cells in the priority queue). The algorithm will continue until the queue is empty. The cost to go is calculated using the L-stage additive cost which considers the terrain cost as well as edge costs that are present. 
				\\
				Once again the same priority queue as implemented in the greedy algorithm was utilized with changes to the priority value. In addition to that, the class \textbf{DijkstraPlanner} inherits from another class \textbf{DynamicPLanner}. This is due to the fact that Dijkstra and A* planners are both dynamic planners and not only use the same queue but only differ by the addition of heuristics. Therefore, the priority queue and functions associated with it are common to both and can therefore be shared. Additionally, the \textbf{resolveDuplicate} function is also shared amongst the two planners. In the case a cell is revisited, the existing cost to go and the new proposed cost to go are compared. If the new cost to go is smaller, then the cell's parent and cost to go are updated to reflect this. 
				\\
				The main advantage of utilizing Dijkstra's is the fact that the optimality of the path is guaranteed. In addition to this, Dijkstra computes the path to the goal from not only the start cell but all cells that have been visited. This means that if at a later date another path to the same goal is required, the algorithm doesn't have to restart from beginning. The main disadvantage is that the algorithm is computationally intense having a time complexity of $O(E\log(V)+E)$ where V are vertices/cells and E are edges. 
				
			\subsubsection{A* Search}
			
				This algorithm works in a similar way to Dijkstraâ€™s however it additionally uses a heuristic to influence the way it selects which cells to explore and visit. Heuristics used in our assignments are: a non-negative constant value, the euclidean distance to the goal, the octile distance to the goal and the Manhattan distance to the goal. The algorithm is similar to Dijkstra and as previously discussed the two planners inherit from the same \textbf{DynamicPlanner} class. When adding a cell to the priority queue, the heuristic value is computed for that cell and it is summed to the L-stage additive cost. This means that the heuristic influences the position of the cell in the priority queue and therefore may change the order in which cells are considered. The heuristics bias the considered cells such that cells closer to the goal are considered first meaning that fewer cells my be visited in the process of finding the final path.
				\\
				The euclidean distance is the straight line distance between two points expressed as shown in Eq. X. 
				
				\begin{equation}
					\hat{G}_{k} = \sqrt{(x_k-x_G)^2+(y_k-y_G)^2}
				\end{equation}
				
				Depending on robot movement restrictions, the heuristic may be altered to take this into account. For example, the octile distance is the minimal distance using horizontal, vertical and 45 degree offset trajectories. This corresponds to a robot that can move in 8 directions (N, NE, E, SE, S, etc...). The expression for computing this distance is shown in Eq. X.
				
				\begin{equation}
				\hat{G}_{k} = max(|x_k-x_G|,|y_k-y_G|) + (\sqrt{2}-1)min(|x_k-x_G|,|y_k-y_G|)
				\end{equation}
				
				Similarly to the octile distance, the Manhattan distance computes the shortest distance between two points using only vertical and horizontal trajectories. This corresponds to a robot that can move in 4 directions (N, E, S, W). The expression to compute this distance is shown in Eq. X. 
				
				\begin{equation}
				\hat{G}_{k} = |x_k-x_G|+|y_k-y_G|
				\end{equation}
				
				Given that the chosen heuristic is non-zero and never overestimates the cost to the goal, the heuristic is said to be admissible. In the case that a heuristic is admissible, it also follows that the computed path will be the optimal path. The most optimal heuristic will be the one that doesn't just approximate the distance to the goal but rather is exactly equal to the cost to the goal. In this case, the number of cells visited will be minimal and the optimal path will also be identified. However, this is non feasible as computing the actual cost to goal is computationally intense. In the case a heuristic is inadmissible, the optimality of the path is not guaranteed.
				\\
				In addition to the type of heuristic used, the A* planner can be further customized and tuned by using a weighting parameter on the heuristic. This weighting parameter influences the number of cells searched by the planner and the optimality of the found path. By choosing a weighting factor greater than 1, the algorithm prioritizes cells closer to the goal. However this also means that the weighted heuristic may become inadmissible and therefore not necessarily derive the optimal path. On the other hand, a weighting factor lower than 1 explores more cells than the un-weighted heuristic but will return the same optimal path. This additional exploration of cells may only be useful, if paths from those cells to the goal are required at a later time. 
				\\
				As previously discussed, the implementation of the A* algorithm is very similar to the implementation of Dijkstra. The main difference is the addition of the \textbf{calc\_heuristics} function that computes the heuristics. The choice of heuristic is defined in the launch file and can be determined as a argument when launching the node using roslaunch.
				\\
				The time complexity of the A* algorithm can be expressed as $O(E)$ where E is the total number of edges in the graph.
				
		\subsection{Algorithm Performance}
			\subsubsection{Metrics to Quantify Performance}
				To measure and evaluate the performance of the planners, five metrics were utilized: Path cost of optimal path, total angle turned, maximum queue cardinality, total number of cells visited and path cardinality. The path cost refers to the total cost of traversing the path returned by the planning algorithm. The total angle turned corresponds to the sum of the absolute value of all of the individual turns the robot has to make. The maximum queue cardinality is the maximum number of elements the queue had at any point in the planning process. This reflects the memory usage of the algorithm. The total number of cells visited is as the name implies and reflects the time taken for the planner to compute the path. Finally the path cardinality is a count of the number of individual waypoints in the path.
				\\
				To compute the cost of the path the L-stage additive cost between the parent of a cell and the cell is computed for every cell on the path. This will give the total cost of traversing the path. This is done in the \textbf{extractPathEndingAtCell} function which starts from the goal and backtracks to the initial cell, cell by cell to compute the planned path.
				\\
				To compute the total angle turned, the trajectory of the robot was considered. By trajectory what is meant is the direction the robot is facing/moving at any point in the path. This is computed by taking the arctangent of the ratio between the difference in y coordinates and the difference in x coordinates of the cells. Whenever there is a change in trajectory, the difference in the trajectory will give the turned angle. The sum of the absolute values of these angles corresponds to the total angle turned. 
				\\
				The maximum queue cardinality was easily implemented by checking the size of the queue every time a new cell was added and updating the maximum value if it is exceeded.
				\\
				The total number of cells visited is computed easily in the implementation of the general search algorithm. Every time a new cell is added to the queue, the number of cells visited is incremented by one. 
				\\
				The path cardinality is computed by taking the length of the planned path which corresponds to the number of cells on the planned path. This is done after having traversed through all cells from the goal to the initial cell. 
				\\
				These metrics should give a good measure of how well a planning algorithm performs. A lower path cost represents a more optimal path while a larger number of cells visited may imply a inefficient algorithm. 
			\subsubsection{Comparing Performance of Algorithms}
			
			\subsubsection{Planner Performance Prognosis}
			
				Describe the metrics used to compare performance \\
				Descirbe how they were implemented \\
				Compare and explain the difference in performance of the algorithms (See Teams for more details)
	

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%% PART 2 %%%%%%%%%%%%%%%%%
	\section{Implementation in ROS}
	
		\subsection{Implentation of Planning Algorithms}
		
		\subsection{Comparison of planners}
		
		\subsection{Description of Robot Controller}
	controller 
	- Improved on P
	- Considered PID 
	- Considered reducing the number of waypoints to make controlling better 
	- Sampling rate can be a factor 
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\newpage
	
	\appendix
	\appendixpage
	\addappheadtotoc
	\section{Class Inheritance}
	\subsection{Planner Inheritance}
	\label{appendix:planner}
	\includegraphics[scale=0.6]{images/planner_inheritance.png}
	\subsection{Controller Inheritance}
	\label{appendix:controller}
	\includegraphics[scale=0.6]{images/controller_inheritance.png}
	
\end{document}